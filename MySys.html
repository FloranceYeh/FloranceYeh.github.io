<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>双星系统简化模拟</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      color: white;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
      width: 100vw;
    }

    .control {
      position: absolute;
      left: 20px;
      z-index: 10;
      user-select: none;
    }

    #speedSlider {
      bottom: 20px;
      width: 200px;
    }

    label[for="speedSlider"] {
      bottom: 50px;
    }

    #toggleOrbit {
      bottom: 100px;
      padding: 10px;
      font-size: 16px;
    }
  </style>
</head>

<body>
  <label for="speedSlider" class="control">动画速度:</label>
  <input type="range" id="speedSlider" min="0" max="0.5" step="0.01" value="0" class="control">
  <button id="toggleOrbit" class="control">隐藏轨道</button>
  <canvas id="spaceCanvas"></canvas>
  <script>
    // 常量定义
    const MIN_SCALE = 1;
    const MAX_SCALE = 10;
    const ZOOM_FACTOR = 1.1;
    
    // DOM 元素
    const canvas = document.getElementById('spaceCanvas');
    const ctx = canvas.getContext('2d');
    const speedSlider = document.getElementById('speedSlider');
    const toggleOrbitButton = document.getElementById('toggleOrbit');
    
    // 状态变量
    let scale = 2;
    let fontsize = 10 * scale;
    let linewidth = scale;
    let centerX, centerY;
    let animationSpeed = 0;
    let showOrbit = true;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    // 光晕参数定义
    const HALO_PARAMS = {
      'R': { sizeMultiplier: 2.5, alpha: 0.5, steps: 5 },
      'B': { sizeMultiplier: 3.0, alpha: 0.5, steps: 4 },
      'F': { sizeMultiplier: 1.8, alpha: 0.3, steps: 3 },
      'S': { sizeMultiplier: 1.5, alpha: 0.2, steps: 2 },
      'T': { sizeMultiplier: 1.5, alpha: 0.2, steps: 2 }
    };
    
    // 天体数据模型（使用马克龙色系）
    const celestialBodies = [
      { id: 'R', r: 20, T: 1, color: 'rgb(255, 213, 79)', size: 10, name: 'R', angle: 0, parent: null, isStar: true, textOffsetX: 15, textOffsetY: 0 },
      { id: 'B', r: 60, T: 1, color: 'rgb(179, 229, 252)', size: 5, name: 'B', angle: Math.PI, parent: null, isStar: true, textOffsetX: 15, textOffsetY: 0 },
      { id: 'F', r: 180, T: 5, color: 'rgb(255, 147, 246)', size: 5, name: 'F', angle: 0, parent: null, isStar: false, textOffsetX: 15, textOffsetY: 0 },
      { id: 'S', r: 20, T: 0.2, color: 'rgb(174, 213, 129)', size: 3, name: 'S', angle: 0, parent: 'B', isStar: false, textOffsetX: 15, textOffsetY: 0 },
      { id: 'T', r: 52, T: 1, color: 'rgb(248, 107, 108)', size: 3, name: 'T', angle: Math.PI / 2, parent: 'binary-center', isStar: false, textOffsetX: 15, textOffsetY: 0 }
    ];
    
    // 在需要用到的函数外部声明，避免多次查找
    const starR = celestialBodies.find(b => b.id === 'R');
    const starB = celestialBodies.find(b => b.id === 'B');
    
    // 初始化画布
    function initCanvas() {
      // 物理像素适配
      const dpr = window.devicePixelRatio || 1;
      canvas.width = window.innerWidth * dpr;
      canvas.height = window.innerHeight * dpr;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      ctx.setTransform(1, 0, 0, 1, 0, 0); // 重置变换
      ctx.scale(dpr, dpr);

      centerX = window.innerWidth / 2;
      centerY = window.innerHeight / 2;

      updateScale(scale);
    }
    
    // 更新缩放
    function updateScale(newScale) {
      scale = newScale;
      fontsize = 10 * scale;
      linewidth = scale;
      
      celestialBodies.forEach(body => {
        body.renderR = body.r * scale;
        body.renderSize = body.size * scale;
      });
    }
    
    // 计算天体位置
    function calculatePosition(body) {
      if (!body.parent) {
        return {
          x: centerX + body.renderR * Math.cos(body.angle),
          y: centerY + body.renderR * Math.sin(body.angle)
        };
      }
      
      if (body.parent === 'binary-center') {
        const starRX = centerX + starR.renderR * Math.cos(starR.angle);
        const starRY = centerY + starR.renderR * Math.sin(starR.angle);
        const starBX = centerX + starB.renderR * Math.cos(starB.angle);
        const starBY = centerY + starB.renderR * Math.sin(starB.angle);
        const midX = (starRX + starBX) / 2;
        const midY = (starRY + starBY) / 2;
        
        return {
          x: midX + body.renderR * Math.cos(body.angle),
          y: midY + body.renderR * Math.sin(body.angle)
        };
      }
      
      const parent = celestialBodies.find(b => b.id === body.parent);
      const parentPos = calculatePosition(parent);
      
      return {
        x: parentPos.x + body.renderR * Math.cos(body.angle),
        y: parentPos.y + body.renderR * Math.sin(body.angle)
      };
    }
    
    // 绘制恒星光晕
    function drawHalo(body) {
      const { x, y } = calculatePosition(body);
      const params = HALO_PARAMS[body.id] || HALO_PARAMS['default'];
      
      ctx.save();
      
      for (let i = params.steps; i > 0; i--) {
        const sizeFactor = 1 + (params.sizeMultiplier - 1) * (i / params.steps);
        const alpha = params.alpha * (i / params.steps);
        
        ctx.beginPath();
        ctx.arc(x, y, body.renderSize * sizeFactor, 0, Math.PI * 2);
        
        // 创建径向渐变
        const gradient = ctx.createRadialGradient(
          x, y, 0,
          x, y, body.renderSize * sizeFactor
        );
        
        // 获取颜色的RGB值
        const rgb = body.color.match(/\d+/g).map(Number);
        
        // 设置渐变
        gradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha * 0.7})`);
        gradient.addColorStop(1, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    // 绘制天体
    function drawCelestialBody(body) {
      // 为恒星绘制光晕
      if (body.isStar) {
        drawHalo(body);
      }
      
      const { x, y } = calculatePosition(body);
      
      ctx.font = `${fontsize}px Arial`;
      ctx.fillStyle = body.color;
      
      // 绘制天体本体
      ctx.beginPath();
      ctx.arc(x, y, body.renderSize, 0, Math.PI * 2);
      ctx.fill();
      
      // 绘制名称
      ctx.fillText(body.name, x + (body.name === 'S' ? 5 : 15) * scale, y);
    }
    
    // 绘制轨道
    function drawOrbit(body) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = linewidth;
      ctx.beginPath();
      
      if (!body.parent) {
        ctx.arc(centerX, centerY, body.renderR, 0, Math.PI * 2);
      } else if (body.parent === 'binary-center') {
        const starRX = centerX + starR.renderR * Math.cos(starR.angle);
        const starRY = centerY + starR.renderR * Math.sin(starR.angle);
        const starBX = centerX + starB.renderR * Math.cos(starB.angle);
        const starBY = centerY + starB.renderR * Math.sin(starB.angle);
        const midX = (starRX + starBX) / 2;
        const midY = (starRY + starBY) / 2;
        ctx.arc(midX, midY, body.renderR, 0, Math.PI * 2);
      } else {
        const parent = celestialBodies.find(b => b.id === body.parent);
        const { x, y } = calculatePosition(parent);
        ctx.arc(x, y, body.renderR, 0, Math.PI * 2);
      }
      
      ctx.stroke();
    }
    
    // 动画循环
    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // 绘制轨道
      if (showOrbit) {
        celestialBodies.forEach(drawOrbit);
      }
      
      // 绘制天体
      celestialBodies.forEach(drawCelestialBody);
      
      // 更新角度
      celestialBodies.forEach(body => {
        body.angle = (body.angle + (2 * Math.PI) / (body.T * 60) * animationSpeed) % (2 * Math.PI);
      });
      
      requestAnimationFrame(animate);
    }
    
    // 事件监听
    function setupEventListeners() {
      // 速度控制
      speedSlider.addEventListener('input', () => {
        animationSpeed = parseFloat(speedSlider.value);
      });
      
      // 轨道显示
      toggleOrbitButton.addEventListener('click', () => {
        showOrbit = !showOrbit;
        toggleOrbitButton.textContent = showOrbit ? '隐藏轨道' : '显示轨道';
      });
      
      // 滚轮缩放
      canvas.addEventListener('wheel', (event) => {
        event.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = (event.clientX - rect.left);
        const mouseY = (event.clientY - rect.top);
        const prevScale = scale;
        const zoomDirection = event.deltaY > 0 ? -1 : 1;
        const newScale = scale * (zoomDirection > 0 ? ZOOM_FACTOR : 1 / ZOOM_FACTOR);

        if (newScale >= MIN_SCALE && newScale <= MAX_SCALE) {
          // 缩放中心跟随鼠标
          centerX = mouseX - (mouseX - centerX) * (newScale / prevScale);
          centerY = mouseY - (mouseY - centerY) * (newScale / prevScale);
          updateScale(newScale);
        }
      });
      
      // 鼠标拖动
      canvas.addEventListener('mousedown', (event) => {
        if (event.button === 0) {
          isDragging = true;
          lastMouseX = event.clientX;
          lastMouseY = event.clientY;
        }
      });
      
      canvas.addEventListener('mousemove', (event) => {
        if (isDragging) {
          const dx = event.movementX;
          const dy = event.movementY;
          centerX += dx;
          centerY += dy;
        }
      });
      
      canvas.addEventListener('mouseup', (event) => {
        if (event.button === 0) {
          isDragging = false;
        }
      });
      
      canvas.addEventListener('mouseleave', () => {
        isDragging = false;
      });
      
      // 窗口大小调整
      window.addEventListener('resize', () => {
        const oldWidth = canvas.width;
        const oldHeight = canvas.height;
        
        canvas.width = window.innerWidth * scale;
        canvas.height = window.innerHeight * scale;
        
        // 保持中心点位置
        centerX = centerX * (canvas.width / oldWidth);
        centerY = centerY * (canvas.height / oldHeight);
      });
    }
    
    // 初始化应用
    function init() {
      initCanvas();
      setupEventListeners();
      animate();
    }
    
    // 启动应用
    init();
  </script>
</body>

</html>